// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

/**
 * @title FeeGenerator
 * @notice Contract yang menghasilkan fees untuk Base Builders December program
 * @dev Contract ini memungkinkan user untuk melakukan transaksi yang menghasilkan fees
 */
contract FeeGenerator is Ownable, ReentrancyGuard {
    uint256 public constant MIN_DEPOSIT = 0.001 ether;
    uint256 public constant FEE_PERCENTAGE = 2; // 2% fee
    uint256 public totalFeesGenerated;
    uint256 public totalDeposits;
    uint256 public totalWithdrawals;
    
    mapping(address => uint256) public balances;
    mapping(address => uint256) public userFeesPaid;
    
    event Deposit(address indexed user, uint256 amount, uint256 fee);
    event Withdraw(address indexed user, uint256 amount, uint256 fee);
    event FeeCollected(address indexed user, uint256 feeAmount);
    
    constructor() Ownable(msg.sender) {}
    
    /**
     * @notice Deposit ETH dengan fee 2%
     * @dev Fee akan dikumpulkan dan ditambahkan ke totalFeesGenerated
     */
    function deposit() external payable nonReentrant {
        require(msg.value >= MIN_DEPOSIT, "Minimum deposit is 0.001 ETH");
        
        uint256 fee = (msg.value * FEE_PERCENTAGE) / 100;
        uint256 depositAmount = msg.value - fee;
        
        balances[msg.sender] += depositAmount;
        totalFeesGenerated += fee;
        totalDeposits += depositAmount;
        userFeesPaid[msg.sender] += fee;
        
        emit Deposit(msg.sender, depositAmount, fee);
        emit FeeCollected(msg.sender, fee);
    }
    
    /**
     * @notice Withdraw ETH dengan fee 2%
     * @param amount Amount to withdraw
     */
    function withdraw(uint256 amount) external nonReentrant {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        require(amount > 0, "Amount must be greater than 0");
        
        uint256 fee = (amount * FEE_PERCENTAGE) / 100;
        uint256 withdrawAmount = amount - fee;
        
        balances[msg.sender] -= amount;
        totalFeesGenerated += fee;
        totalWithdrawals += withdrawAmount;
        userFeesPaid[msg.sender] += fee;
        
        (bool success, ) = msg.sender.call{value: withdrawAmount}("");
        require(success, "Transfer failed");
        
        emit Withdraw(msg.sender, withdrawAmount, fee);
        emit FeeCollected(msg.sender, fee);
    }
    
    /**
     * @notice Get user balance
     */
    function getBalance() external view returns (uint256) {
        return balances[msg.sender];
    }
    
    /**
     * @notice Get total fees generated by this contract
     */
    function getTotalFees() external view returns (uint256) {
        return totalFeesGenerated;
    }
    
    /**
     * @notice Owner can withdraw collected fees
     */
    function withdrawFees() external onlyOwner {
        uint256 amount = address(this).balance;
        require(amount > 0, "No fees to withdraw");
        
        (bool success, ) = owner().call{value: amount}("");
        require(success, "Transfer failed");
    }
    
    /**
     * @notice Get contract statistics
     */
    function getStats() external view returns (
        uint256 _totalFeesGenerated,
        uint256 _totalDeposits,
        uint256 _totalWithdrawals,
        uint256 _contractBalance
    ) {
        return (
            totalFeesGenerated,
            totalDeposits,
            totalWithdrawals,
            address(this).balance
        );
    }
}
